From d48d156bb8f5a212f004a5383505220cfba323e9 Mon Sep 17 00:00:00 2001
From: Roman Stratiienko <r.stratiienko@gmail.com>
Date: Fri, 6 Oct 2023 22:21:43 +0300
Subject: [PATCH 09/12] hals/usb-gadget: Use AOSP libusbconfigfs-2

It already has all the required functionality.

Signed-off-by: Roman Stratiienko <r.stratiienko@gmail.com>
---
 hals/usb-gadget/Android.bp                    |   2 +-
 hals/usb-gadget/lib/Android.bp                |  41 ---
 hals/usb-gadget/lib/MonitorFfs.cpp            | 269 ------------------
 hals/usb-gadget/lib/UsbGadgetUtils.cpp        | 207 --------------
 hals/usb-gadget/lib/include/UsbGadgetCommon.h | 179 ------------
 5 files changed, 1 insertion(+), 697 deletions(-)
 delete mode 100644 hals/usb-gadget/lib/Android.bp
 delete mode 100644 hals/usb-gadget/lib/MonitorFfs.cpp
 delete mode 100644 hals/usb-gadget/lib/UsbGadgetUtils.cpp
 delete mode 100644 hals/usb-gadget/lib/include/UsbGadgetCommon.h

diff --git a/hals/usb-gadget/Android.bp b/hals/usb-gadget/Android.bp
index 3c3ea45..64b1250 100644
--- a/hals/usb-gadget/Android.bp
+++ b/hals/usb-gadget/Android.bp
@@ -36,5 +36,5 @@ cc_binary {
         "liblog",
         "libutils",
     ],
-    static_libs: ["libusbconfigfs-2-gd"],
+    static_libs: ["libusbconfigfs-2"],
 }
diff --git a/hals/usb-gadget/lib/Android.bp b/hals/usb-gadget/lib/Android.bp
deleted file mode 100644
index 3c57acb..0000000
--- a/hals/usb-gadget/lib/Android.bp
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-cc_library_static {
-    name: "libusbconfigfs-2-gd",
-    vendor_available: true,
-    export_include_dirs: ["include"],
-
-    srcs: [
-        "UsbGadgetUtils.cpp",
-        "MonitorFfs.cpp",
-    ],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-    ],
-
-    shared_libs: [
-        "android.hardware.usb.gadget@1.0",
-        "android.hardware.usb.gadget@1.1",
-        "android.hardware.usb.gadget@1.2",
-        "libbase",
-        "libcutils",
-        "libhidlbase",
-        "libutils",
-    ],
-}
diff --git a/hals/usb-gadget/lib/MonitorFfs.cpp b/hals/usb-gadget/lib/MonitorFfs.cpp
deleted file mode 100644
index 0cdf038..0000000
--- a/hals/usb-gadget/lib/MonitorFfs.cpp
+++ /dev/null
@@ -1,269 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "libusbconfigfs"
-
-#include "include/UsbGadgetCommon.h"
-
-namespace android {
-namespace hardware {
-namespace usb {
-namespace gadget {
-
-static volatile bool gadgetPullup;
-
-MonitorFfs::MonitorFfs(const char* const gadget)
-    : mWatchFd(),
-      mEndpointList(),
-      mLock(),
-      mCv(),
-      mLockFd(),
-      mCurrentUsbFunctionsApplied(false),
-      mMonitor(),
-      mCallback(NULL),
-      mPayload(NULL),
-      mGadgetName(gadget),
-      mMonitorRunning(false) {
-    unique_fd eventFd(eventfd(0, 0));
-    if (eventFd == -1) {
-        ALOGE("mEventFd failed to create %d", errno);
-        abort();
-    }
-
-    unique_fd epollFd(epoll_create(2));
-    if (epollFd == -1) {
-        ALOGE("mEpollFd failed to create %d", errno);
-        abort();
-    }
-
-    unique_fd inotifyFd(inotify_init());
-    if (inotifyFd < 0) {
-        ALOGE("inotify init failed");
-        abort();
-    }
-
-    if (addEpollFd(epollFd, inotifyFd) == -1) abort();
-
-    if (addEpollFd(epollFd, eventFd) == -1) abort();
-
-    mEpollFd = move(epollFd);
-    mInotifyFd = move(inotifyFd);
-    mEventFd = move(eventFd);
-    gadgetPullup = false;
-}
-
-static void displayInotifyEvent(struct inotify_event* i) {
-    ALOGE("    wd =%2d; ", i->wd);
-    if (i->cookie > 0) ALOGE("cookie =%4d; ", i->cookie);
-
-    ALOGE("mask = ");
-    if (i->mask & IN_ACCESS) ALOGE("IN_ACCESS ");
-    if (i->mask & IN_ATTRIB) ALOGE("IN_ATTRIB ");
-    if (i->mask & IN_CLOSE_NOWRITE) ALOGE("IN_CLOSE_NOWRITE ");
-    if (i->mask & IN_CLOSE_WRITE) ALOGE("IN_CLOSE_WRITE ");
-    if (i->mask & IN_CREATE) ALOGE("IN_CREATE ");
-    if (i->mask & IN_DELETE) ALOGE("IN_DELETE ");
-    if (i->mask & IN_DELETE_SELF) ALOGE("IN_DELETE_SELF ");
-    if (i->mask & IN_IGNORED) ALOGE("IN_IGNORED ");
-    if (i->mask & IN_ISDIR) ALOGE("IN_ISDIR ");
-    if (i->mask & IN_MODIFY) ALOGE("IN_MODIFY ");
-    if (i->mask & IN_MOVE_SELF) ALOGE("IN_MOVE_SELF ");
-    if (i->mask & IN_MOVED_FROM) ALOGE("IN_MOVED_FROM ");
-    if (i->mask & IN_MOVED_TO) ALOGE("IN_MOVED_TO ");
-    if (i->mask & IN_OPEN) ALOGE("IN_OPEN ");
-    if (i->mask & IN_Q_OVERFLOW) ALOGE("IN_Q_OVERFLOW ");
-    if (i->mask & IN_UNMOUNT) ALOGE("IN_UNMOUNT ");
-    ALOGE("\n");
-
-    if (i->len > 0) ALOGE("        name = %s\n", i->name);
-}
-
-void* MonitorFfs::startMonitorFd(void* param) {
-    MonitorFfs* monitorFfs = (MonitorFfs*)param;
-    char buf[kBufferSize];
-    bool writeUdc = true, stopMonitor = false;
-    struct epoll_event events[kEpollEvents];
-    steady_clock::time_point disconnect;
-
-    bool descriptorWritten = true;
-    for (int i = 0; i < static_cast<int>(monitorFfs->mEndpointList.size()); i++) {
-        if (access(monitorFfs->mEndpointList.at(i).c_str(), R_OK)) {
-            descriptorWritten = false;
-            break;
-        }
-    }
-
-    // notify here if the endpoints are already present.
-    if (descriptorWritten) {
-        usleep(kPullUpDelay);
-        if (!!WriteStringToFile(monitorFfs->mGadgetName, PULLUP_PATH)) {
-            lock_guard<mutex> lock(monitorFfs->mLock);
-            monitorFfs->mCurrentUsbFunctionsApplied = true;
-            monitorFfs->mCallback(monitorFfs->mCurrentUsbFunctionsApplied, monitorFfs->mPayload);
-            gadgetPullup = true;
-            writeUdc = false;
-            ALOGI("GADGET pulled up");
-            monitorFfs->mCv.notify_all();
-        }
-    }
-
-    while (!stopMonitor) {
-        int nrEvents = epoll_wait(monitorFfs->mEpollFd, events, kEpollEvents, -1);
-
-        if (nrEvents <= 0) {
-            ALOGE("epoll wait did not return descriptor number");
-            continue;
-        }
-
-        for (int i = 0; i < nrEvents; i++) {
-            ALOGI("event=%u on fd=%d\n", events[i].events, events[i].data.fd);
-
-            if (events[i].data.fd == monitorFfs->mInotifyFd) {
-                // Process all of the events in buffer returned by read().
-                int numRead = read(monitorFfs->mInotifyFd, buf, kBufferSize);
-                for (char* p = buf; p < buf + numRead;) {
-                    struct inotify_event* event = (struct inotify_event*)p;
-                    if (kDebug) displayInotifyEvent(event);
-
-                    p += sizeof(struct inotify_event) + event->len;
-
-                    bool descriptorPresent = true;
-                    for (int j = 0; j < static_cast<int>(monitorFfs->mEndpointList.size()); j++) {
-                        if (access(monitorFfs->mEndpointList.at(j).c_str(), R_OK)) {
-                            if (kDebug) ALOGI("%s absent", monitorFfs->mEndpointList.at(j).c_str());
-                            descriptorPresent = false;
-                            break;
-                        }
-                    }
-
-                    if (!descriptorPresent && !writeUdc) {
-                        if (kDebug) ALOGI("endpoints not up");
-                        writeUdc = true;
-                        disconnect = std::chrono::steady_clock::now();
-                    } else if (descriptorPresent && writeUdc) {
-                        steady_clock::time_point temp = steady_clock::now();
-
-                        if (std::chrono::duration_cast<microseconds>(temp - disconnect).count() <
-                            kPullUpDelay)
-                            usleep(kPullUpDelay);
-
-                        if (!!WriteStringToFile(monitorFfs->mGadgetName, PULLUP_PATH)) {
-                            lock_guard<mutex> lock(monitorFfs->mLock);
-                            monitorFfs->mCurrentUsbFunctionsApplied = true;
-                            monitorFfs->mCallback(monitorFfs->mCurrentUsbFunctionsApplied,
-                                                  monitorFfs->mPayload);
-                            ALOGI("GADGET pulled up");
-                            writeUdc = false;
-                            gadgetPullup = true;
-                            // notify the main thread to signal userspace.
-                            monitorFfs->mCv.notify_all();
-                        }
-                    }
-                }
-            } else {
-                uint64_t flag;
-                read(monitorFfs->mEventFd, &flag, sizeof(flag));
-                if (flag == 100) {
-                    stopMonitor = true;
-                    break;
-                }
-            }
-        }
-    }
-    return NULL;
-}
-
-void MonitorFfs::reset() {
-    lock_guard<mutex> lock(mLockFd);
-    uint64_t flag = 100;
-    unsigned long ret;
-
-    if (mMonitorRunning) {
-        // Stop the monitor thread by writing into signal fd.
-        ret = TEMP_FAILURE_RETRY(write(mEventFd, &flag, sizeof(flag)));
-        if (ret < 0) ALOGE("Error writing eventfd errno=%d", errno);
-
-        ALOGI("mMonitor signalled to exit");
-        mMonitor->join();
-        ALOGI("mMonitor destroyed");
-        mMonitorRunning = false;
-    }
-
-    for (std::vector<int>::size_type i = 0; i != mWatchFd.size(); i++)
-        inotify_rm_watch(mInotifyFd, mWatchFd[i]);
-
-    mEndpointList.clear();
-    gadgetPullup = false;
-    mCallback = NULL;
-    mPayload = NULL;
-}
-
-bool MonitorFfs::startMonitor() {
-    mMonitor = unique_ptr<thread>(new thread(this->startMonitorFd, this));
-    mMonitorRunning = true;
-    return true;
-}
-
-bool MonitorFfs::isMonitorRunning() {
-    return mMonitorRunning;
-}
-
-bool MonitorFfs::waitForPullUp(int timeout_ms) {
-    std::unique_lock<std::mutex> lk(mLock);
-
-    if (gadgetPullup) return true;
-
-    if (mCv.wait_for(lk, timeout_ms * 1ms, [] { return gadgetPullup; })) {
-        ALOGI("monitorFfs signalled true");
-        return true;
-    } else {
-        ALOGI("monitorFfs signalled error");
-        // continue monitoring as the descriptors might be written at a later
-        // point.
-        return false;
-    }
-}
-
-bool MonitorFfs::addInotifyFd(string fd) {
-    lock_guard<mutex> lock(mLockFd);
-    int wfd;
-
-    wfd = inotify_add_watch(mInotifyFd, fd.c_str(), IN_ALL_EVENTS);
-    if (wfd == -1)
-        return false;
-    else
-        mWatchFd.push_back(wfd);
-
-    return true;
-}
-
-void MonitorFfs::addEndPoint(string ep) {
-    lock_guard<mutex> lock(mLockFd);
-
-    mEndpointList.push_back(ep);
-}
-
-void MonitorFfs::registerFunctionsAppliedCallback(void (*callback)(bool functionsApplied,
-                                                                   void* payload),
-                                                  void* payload) {
-    mCallback = callback;
-    mPayload = payload;
-}
-
-}  // namespace gadget
-}  // namespace usb
-}  // namespace hardware
-}  // namespace android
diff --git a/hals/usb-gadget/lib/UsbGadgetUtils.cpp b/hals/usb-gadget/lib/UsbGadgetUtils.cpp
deleted file mode 100644
index 0924da7..0000000
--- a/hals/usb-gadget/lib/UsbGadgetUtils.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "libusbconfigfs"
-
-#include "include/UsbGadgetCommon.h"
-
-namespace android {
-namespace hardware {
-namespace usb {
-namespace gadget {
-
-int unlinkFunctions(const char* path) {
-    DIR* config = opendir(path);
-    struct dirent* function;
-    char filepath[kMaxFilePathLength];
-    int ret = 0;
-
-    if (config == NULL) return -1;
-
-    // d_type does not seems to be supported in /config
-    // so filtering by name.
-    while (((function = readdir(config)) != NULL)) {
-        if ((strstr(function->d_name, FUNCTION_NAME) == NULL)) continue;
-        // build the path for each file in the folder.
-        sprintf(filepath, "%s/%s", path, function->d_name);
-        ret = remove(filepath);
-        if (ret) {
-            ALOGE("Unable  remove file %s errno:%d", filepath, errno);
-            break;
-        }
-    }
-
-    closedir(config);
-    return ret;
-}
-
-int addEpollFd(const unique_fd& epfd, const unique_fd& fd) {
-    struct epoll_event event;
-    int ret;
-
-    event.data.fd = fd;
-    event.events = EPOLLIN;
-
-    ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event);
-    if (ret) ALOGE("epoll_ctl error %d", errno);
-
-    return ret;
-}
-
-int linkFunction(const char* function, int index) {
-    char functionPath[kMaxFilePathLength];
-    char link[kMaxFilePathLength];
-
-    sprintf(functionPath, "%s%s", FUNCTIONS_PATH, function);
-    sprintf(link, "%s%d", FUNCTION_PATH, index);
-    if (symlink(functionPath, link)) {
-        ALOGE("Cannot create symlink %s -> %s errno:%d", link, functionPath, errno);
-        return -1;
-    }
-    return 0;
-}
-
-Status setVidPid(const char* vid, const char* pid) {
-    if (!WriteStringToFile(vid, VENDOR_ID_PATH)) return Status::ERROR;
-
-    if (!WriteStringToFile(pid, PRODUCT_ID_PATH)) return Status::ERROR;
-
-    return Status::SUCCESS;
-}
-
-std::string getVendorFunctions() {
-    if (GetProperty(kBuildType, "") == "user") return "user";
-
-    std::string bootMode = GetProperty(PERSISTENT_BOOT_MODE, "");
-    std::string persistVendorFunctions = GetProperty(kPersistentVendorConfig, "");
-    std::string vendorFunctions = GetProperty(kVendorConfig, "");
-    std::string ret = "";
-
-    if (vendorFunctions != "") {
-        ret = vendorFunctions;
-    } else if (bootMode == "usbradio" || bootMode == "factory" || bootMode == "ffbm-00" ||
-               bootMode == "ffbm-01") {
-        if (persistVendorFunctions != "")
-            ret = persistVendorFunctions;
-        else
-            ret = "diag";
-        // vendor.usb.config will reflect the current configured functions
-        SetProperty(kVendorConfig, ret);
-    }
-
-    return ret;
-}
-
-Status resetGadget() {
-    ALOGI("setCurrentUsbFunctions None");
-
-    if (!WriteStringToFile("none", PULLUP_PATH)) ALOGI("Gadget cannot be pulled down");
-
-    if (!WriteStringToFile("0", DEVICE_CLASS_PATH)) return Status::ERROR;
-
-    if (!WriteStringToFile("0", DEVICE_SUB_CLASS_PATH)) return Status::ERROR;
-
-    if (!WriteStringToFile("0", DEVICE_PROTOCOL_PATH)) return Status::ERROR;
-
-    if (!WriteStringToFile("0", DESC_USE_PATH)) return Status::ERROR;
-
-    if (unlinkFunctions(CONFIG_PATH)) return Status::ERROR;
-
-    return Status::SUCCESS;
-}
-
-Status addGenericAndroidFunctions(MonitorFfs* monitorFfs, uint64_t functions, bool* ffsEnabled,
-                                  int* functionCount) {
-    if (((functions & GadgetFunction::MTP) != 0)) {
-        *ffsEnabled = true;
-        ALOGI("setCurrentUsbFunctions mtp");
-        if (!WriteStringToFile("1", DESC_USE_PATH)) return Status::ERROR;
-
-        if (!monitorFfs->addInotifyFd("/dev/usb-ffs/mtp/")) return Status::ERROR;
-
-        if (linkFunction("ffs.mtp", (*functionCount)++)) return Status::ERROR;
-
-        // Add endpoints to be monitored.
-        monitorFfs->addEndPoint("/dev/usb-ffs/mtp/ep1");
-        monitorFfs->addEndPoint("/dev/usb-ffs/mtp/ep2");
-        monitorFfs->addEndPoint("/dev/usb-ffs/mtp/ep3");
-    } else if (((functions & GadgetFunction::PTP) != 0)) {
-        *ffsEnabled = true;
-        ALOGI("setCurrentUsbFunctions ptp");
-        if (!WriteStringToFile("1", DESC_USE_PATH)) return Status::ERROR;
-
-        if (!monitorFfs->addInotifyFd("/dev/usb-ffs/ptp/")) return Status::ERROR;
-
-        if (linkFunction("ffs.ptp", (*functionCount)++)) return Status::ERROR;
-
-        // Add endpoints to be monitored.
-        monitorFfs->addEndPoint("/dev/usb-ffs/ptp/ep1");
-        monitorFfs->addEndPoint("/dev/usb-ffs/ptp/ep2");
-        monitorFfs->addEndPoint("/dev/usb-ffs/ptp/ep3");
-    }
-
-    if ((functions & GadgetFunction::MIDI) != 0) {
-        ALOGI("setCurrentUsbFunctions MIDI");
-        if (linkFunction("midi.gs5", (*functionCount)++)) return Status::ERROR;
-    }
-
-    if ((functions & GadgetFunction::ACCESSORY) != 0) {
-        ALOGI("setCurrentUsbFunctions Accessory");
-        if (linkFunction("accessory.gs2", (*functionCount)++)) return Status::ERROR;
-    }
-
-    if ((functions & GadgetFunction::AUDIO_SOURCE) != 0) {
-        ALOGI("setCurrentUsbFunctions Audio Source");
-        if (linkFunction("audio_source.gs3", (*functionCount)++)) return Status::ERROR;
-    }
-
-    if ((functions & GadgetFunction::RNDIS) != 0) {
-        ALOGI("setCurrentUsbFunctions rndis");
-        std::string rndisFunction = GetProperty(kVendorRndisConfig, "");
-        if (rndisFunction != "") {
-            if (linkFunction(rndisFunction.c_str(), (*functionCount)++)) return Status::ERROR;
-        } else {
-            // link gsi.rndis for older pixel projects
-            if (linkFunction("gsi.rndis", (*functionCount)++)) return Status::ERROR;
-        }
-    }
-
-    if ((functions & GadgetFunction::NCM) != 0) {
-        ALOGI("setCurrentUsbFunctions ncm");
-        if (linkFunction("ncm.gs6", (*functionCount)++)) return Status::ERROR;
-    }
-
-    return Status::SUCCESS;
-}
-
-Status addAdb(MonitorFfs* monitorFfs, int* functionCount) {
-    ALOGI("setCurrentUsbFunctions Adb");
-    if (!WriteStringToFile("1", DESC_USE_PATH))
-        return Status::ERROR;
-
-    if (!monitorFfs->addInotifyFd("/dev/usb-ffs/adb/")) return Status::ERROR;
-
-    if (linkFunction("ffs.adb", (*functionCount)++)) return Status::ERROR;
-    monitorFfs->addEndPoint("/dev/usb-ffs/adb/ep1");
-    monitorFfs->addEndPoint("/dev/usb-ffs/adb/ep2");
-    ALOGI("Service started");
-    return Status::SUCCESS;
-}
-
-}  // namespace gadget
-}  // namespace usb
-}  // namespace hardware
-}  // namespace android
diff --git a/hals/usb-gadget/lib/include/UsbGadgetCommon.h b/hals/usb-gadget/lib/include/UsbGadgetCommon.h
deleted file mode 100644
index 18b8101..0000000
--- a/hals/usb-gadget/lib/include/UsbGadgetCommon.h
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * Copyright (C) 2020 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HARDWARE_USB_USBGADGETCOMMON_H
-#define HARDWARE_USB_USBGADGETCOMMON_H
-
-#include <android-base/file.h>
-#include <android-base/properties.h>
-#include <android-base/unique_fd.h>
-
-#include <android/hardware/usb/gadget/1.2/IUsbGadget.h>
-#include <android/hardware/usb/gadget/1.2/types.h>
-
-#include <dirent.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <sys/epoll.h>
-#include <sys/eventfd.h>
-#include <sys/inotify.h>
-#include <sys/mount.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-#include <utils/Log.h>
-#include <chrono>
-#include <condition_variable>
-#include <mutex>
-#include <string>
-#include <thread>
-
-namespace android {
-namespace hardware {
-namespace usb {
-namespace gadget {
-
-constexpr int kBufferSize = 512;
-constexpr int kMaxFilePathLength = 256;
-constexpr int kEpollEvents = 10;
-constexpr bool kDebug = false;
-constexpr int kDisconnectWaitUs = 100000;
-constexpr int kPullUpDelay = 500000;
-constexpr int kShutdownMonitor = 100;
-
-constexpr char kBuildType[] = "ro.build.type";
-constexpr char kPersistentVendorConfig[] = "persist.vendor.usb.usbradio.config";
-constexpr char kVendorConfig[] = "vendor.usb.config";
-constexpr char kVendorRndisConfig[] = "vendor.usb.rndis.config";
-
-#define GADGET_PATH "/config/usb_gadget/g1/"
-#define PULLUP_PATH GADGET_PATH "UDC"
-#define PERSISTENT_BOOT_MODE "ro.bootmode"
-#define VENDOR_ID_PATH GADGET_PATH "idVendor"
-#define PRODUCT_ID_PATH GADGET_PATH "idProduct"
-#define DEVICE_CLASS_PATH GADGET_PATH "bDeviceClass"
-#define DEVICE_SUB_CLASS_PATH GADGET_PATH "bDeviceSubClass"
-#define DEVICE_PROTOCOL_PATH GADGET_PATH "bDeviceProtocol"
-#define DESC_USE_PATH GADGET_PATH "os_desc/use"
-#define OS_DESC_PATH GADGET_PATH "os_desc/b.1"
-#define CONFIG_PATH GADGET_PATH "configs/b.1/"
-#define FUNCTIONS_PATH GADGET_PATH "functions/"
-#define FUNCTION_NAME "function"
-#define FUNCTION_PATH CONFIG_PATH FUNCTION_NAME
-#define RNDIS_PATH FUNCTIONS_PATH "gsi.rndis"
-
-using ::android::base::GetProperty;
-using ::android::base::SetProperty;
-using ::android::base::unique_fd;
-using ::android::base::WriteStringToFile;
-using ::android::hardware::usb::gadget::V1_0::Status;
-using ::android::hardware::usb::gadget::V1_2::GadgetFunction;
-
-using ::std::lock_guard;
-using ::std::move;
-using ::std::mutex;
-using ::std::string;
-using ::std::thread;
-using ::std::unique_ptr;
-using ::std::vector;
-using ::std::chrono::microseconds;
-using ::std::chrono::steady_clock;
-using ::std::literals::chrono_literals::operator""ms;
-
-// MonitorFfs automously manages gadget pullup by monitoring
-// the ep file status. Restarts the usb gadget when the ep
-// owner restarts.
-class MonitorFfs {
-  private:
-    // Monitors the endpoints Inotify events.
-    unique_fd mInotifyFd;
-    // Control pipe for shutting down the mMonitor thread.
-    // mMonitor exits when SHUTDOWN_MONITOR is written into
-    // mEventFd/
-    unique_fd mEventFd;
-    // Pools on mInotifyFd and mEventFd.
-    unique_fd mEpollFd;
-    vector<int> mWatchFd;
-
-    // Maintains the list of Endpoints.
-    vector<string> mEndpointList;
-    // protects the CV.
-    std::mutex mLock;
-    std::condition_variable mCv;
-    // protects mInotifyFd, mEpollFd.
-    std::mutex mLockFd;
-
-    // Flag to maintain the current status of gadget pullup.
-    bool mCurrentUsbFunctionsApplied;
-
-    // Thread object that executes the ep monitoring logic.
-    unique_ptr<thread> mMonitor;
-    // Callback to be invoked when gadget is pulled up.
-    void (*mCallback)(bool functionsApplied, void* payload);
-    void* mPayload;
-    // Name of the USB gadget. Used for pullup.
-    const char* const mGadgetName;
-    // Monitor State
-    bool mMonitorRunning;
-
-  public:
-    MonitorFfs(const char* const gadget);
-    // Inits all the UniqueFds.
-    void reset();
-    // Starts monitoring endpoints and pullup the gadget when
-    // the descriptors are written.
-    bool startMonitor();
-    // Waits for timeout_ms for gadget pull up to happen.
-    // Returns immediately if the gadget is already pulled up.
-    bool waitForPullUp(int timeout_ms);
-    // Adds the given fd to the watch list.
-    bool addInotifyFd(string fd);
-    // Adds the given endpoint to the watch list.
-    void addEndPoint(string ep);
-    // Registers the async callback from the caller to notify the caller
-    // when the gadget pull up happens.
-    void registerFunctionsAppliedCallback(void (*callback)(bool functionsApplied, void*(payload)),
-                                          void* payload);
-    bool isMonitorRunning();
-    // Ep monitoring and the gadget pull up logic.
-    static void* startMonitorFd(void* param);
-};
-
-//**************** Helper functions ************************//
-
-// Adds the given fd to the epollfd(epfd).
-int addEpollFd(const unique_fd& epfd, const unique_fd& fd);
-// Removes all the usb functions link in the specified path.
-int unlinkFunctions(const char* path);
-// Craetes a configfs link for the function.
-int linkFunction(const char* function, int index);
-// Sets the USB VID and PID.
-Status setVidPid(const char* vid, const char* pid);
-// Extracts vendor functions from the vendor init properties.
-std::string getVendorFunctions();
-// Adds Adb to the usb configuration.
-Status addAdb(MonitorFfs* monitorFfs, int* functionCount);
-// Adds all applicable generic android usb functions other than ADB.
-Status addGenericAndroidFunctions(MonitorFfs* monitorFfs, uint64_t functions, bool* ffsEnabled,
-                                  int* functionCount);
-// Pulls down USB gadget.
-Status resetGadget();
-
-}  // namespace gadget
-}  // namespace usb
-}  // namespace hardware
-}  // namespace android
-#endif
-- 
2.39.2

