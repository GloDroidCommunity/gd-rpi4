From 7f60345cf95b8b8c7eb392ac99a68fddaa290eda Mon Sep 17 00:00:00 2001
From: Roman Stratiienko <r.stratiienko@gmail.com>
Date: Sun, 17 Sep 2023 17:41:51 +0300
Subject: [PATCH] WIP: Virtual display support

Change-Id: Ica07d7cfe6b38a7f5cdf2cb3264f347a915fb92a
Signed-off-by: Roman Stratiienko <r.stratiienko@gmail.com>
---
 drm/DrmAtomicStateManager.cpp     | 24 ++++++++++++++++---
 drm/DrmAtomicStateManager.h       |  3 +++
 drm/DrmConnector.h                |  8 +++++++
 drm/DrmDevice.cpp                 |  5 ++++
 drm/DrmDevice.h                   |  2 ++
 drm/ResourceManager.cpp           | 17 ++++++++++++++
 drm/ResourceManager.h             |  2 ++
 hwc2_device/DrmHwcTwo.cpp         | 39 ++++++++++++++++++++++---------
 hwc2_device/HwcDisplay.cpp        | 27 ++++++++++++++++-----
 hwc2_device/HwcDisplay.h          |  5 ++++
 hwc2_device/HwcDisplayConfigs.cpp | 23 +++++++++++++++---
 11 files changed, 132 insertions(+), 23 deletions(-)

diff --git a/drm/DrmAtomicStateManager.cpp b/drm/DrmAtomicStateManager.cpp
index 4ff16e2..ee2d7e1 100644
--- a/drm/DrmAtomicStateManager.cpp
+++ b/drm/DrmAtomicStateManager.cpp
@@ -79,11 +79,29 @@ auto DrmAtomicStateManager::CommitFrame(AtomicCommitArgs &args) -> int {
   }
 
   int out_fence = -1;
-  if (!crtc->GetOutFencePtrProperty().AtomicSet(*pset, uint64_t(&out_fence))) {
-    return -EINVAL;
+  if (!args.writeback_fb) {
+    if (!crtc->GetOutFencePtrProperty().AtomicSet(*pset,
+                                                  uint64_t(&out_fence))) {
+      return -EINVAL;
+    }
+  } else {
+    if (!connector->GetWritebackOutFenceProperty().AtomicSet(*pset,
+                                                             uint64_t(
+                                                                 &out_fence))) {
+      return -EINVAL;
+    }
+
+    if (!connector->GetWritebackFbIdProperty()
+             .AtomicSet(*pset, args.writeback_fb->GetFbId())) {
+      return -EINVAL;
+    }
+
+    if (args.writeback_release_fence) {
+      sync_wait(*args.writeback_release_fence, -1);
+    }
   }
 
-  bool nonblock = true;
+  bool nonblock = false;
 
   if (args.active) {
     nonblock = false;
diff --git a/drm/DrmAtomicStateManager.h b/drm/DrmAtomicStateManager.h
index 6e32a37..e5a0945 100644
--- a/drm/DrmAtomicStateManager.h
+++ b/drm/DrmAtomicStateManager.h
@@ -37,6 +37,9 @@ struct AtomicCommitArgs {
   std::shared_ptr<DrmKmsPlan> composition;
   std::shared_ptr<drm_color_ctm> color_matrix;
 
+  std::shared_ptr<DrmFbIdHandle> writeback_fb;
+  SharedFd writeback_release_fence;
+
   /* out */
   SharedFd out_fence;
 
diff --git a/drm/DrmConnector.h b/drm/DrmConnector.h
index f21f598..018c615 100644
--- a/drm/DrmConnector.h
+++ b/drm/DrmConnector.h
@@ -94,6 +94,14 @@ class DrmConnector : public PipelineBindable<DrmConnector> {
     return edid_property_;
   }
 
+  auto &GetWritebackFbIdProperty() const {
+    return writeback_fb_id_;
+  }
+
+  auto &GetWritebackOutFenceProperty() const {
+    return writeback_out_fence_;
+  }
+
   auto IsConnected() const {
     return connector_->connection == DRM_MODE_CONNECTED;
   }
diff --git a/drm/DrmDevice.cpp b/drm/DrmDevice.cpp
index 1d6b62e..f6f0b01 100644
--- a/drm/DrmDevice.cpp
+++ b/drm/DrmDevice.cpp
@@ -242,6 +242,11 @@ auto DrmDevice::GetConnectors()
   return connectors_;
 }
 
+auto DrmDevice::GetWritebackConnectors()
+    -> const std::vector<std::unique_ptr<DrmConnector>> & {
+  return writeback_connectors_;
+}
+
 auto DrmDevice::GetPlanes() -> const std::vector<std::unique_ptr<DrmPlane>> & {
   return planes_;
 }
diff --git a/drm/DrmDevice.h b/drm/DrmDevice.h
index 39d0c88..cbaa536 100644
--- a/drm/DrmDevice.h
+++ b/drm/DrmDevice.h
@@ -47,6 +47,8 @@ class DrmDevice {
   }
 
   auto GetConnectors() -> const std::vector<std::unique_ptr<DrmConnector>> &;
+  auto GetWritebackConnectors()
+      -> const std::vector<std::unique_ptr<DrmConnector>> &;
   auto GetPlanes() -> const std::vector<std::unique_ptr<DrmPlane>> &;
   auto GetCrtcs() -> const std::vector<std::unique_ptr<DrmCrtc>> &;
   auto GetEncoders() -> const std::vector<std::unique_ptr<DrmEncoder>> &;
diff --git a/drm/ResourceManager.cpp b/drm/ResourceManager.cpp
index 577d86c..a2216ab 100644
--- a/drm/ResourceManager.cpp
+++ b/drm/ResourceManager.cpp
@@ -185,4 +185,21 @@ auto ResourceManager::GetOrderedConnectors() -> std::vector<DrmConnector *> {
 
   return ordered_connectors;
 }
+
+DrmDisplayPipeline *ResourceManager::GetVirtualDisplayPipeline() {
+  for (auto &drm : drms_) {
+    for (const auto &conn : drm->GetWritebackConnectors()) {
+      auto pipeline = DrmDisplayPipeline::CreatePipeline(*conn);
+      if (!pipeline) {
+        ALOGE("Failed to create pipeline for writeback connector %s",
+              conn->GetName().c_str());
+      }
+      if (pipeline) {
+        return pipeline.release();
+      }
+    }
+  }
+  return nullptr;
+}
+
 }  // namespace android
diff --git a/drm/ResourceManager.h b/drm/ResourceManager.h
index 7fa3fc6..233e70c 100644
--- a/drm/ResourceManager.h
+++ b/drm/ResourceManager.h
@@ -65,6 +65,8 @@ class ResourceManager {
     return main_lock_;
   }
 
+  DrmDisplayPipeline *GetVirtualDisplayPipeline();
+
   static auto GetTimeMonotonicNs() -> int64_t;
 
  private:
diff --git a/hwc2_device/DrmHwcTwo.cpp b/hwc2_device/DrmHwcTwo.cpp
index 64755c3..dd3131f 100644
--- a/hwc2_device/DrmHwcTwo.cpp
+++ b/hwc2_device/DrmHwcTwo.cpp
@@ -124,17 +124,34 @@ bool DrmHwcTwo::UnbindDisplay(DrmDisplayPipeline *pipeline) {
   return true;
 }
 
-HWC2::Error DrmHwcTwo::CreateVirtualDisplay(uint32_t /*width*/,
-                                            uint32_t /*height*/,
-                                            int32_t * /*format*/,
-                                            hwc2_display_t * /*display*/) {
-  // TODO(nobody): Implement virtual display
-  return HWC2::Error::Unsupported;
+HWC2::Error DrmHwcTwo::CreateVirtualDisplay(uint32_t width, uint32_t height,
+                                            int32_t *format,
+                                            hwc2_display_t *display) {
+  ALOGI("Creating virtual display %dx%d format %d", width, height, *format);
+
+  auto virtual_pipeline = resource_manager_.GetVirtualDisplayPipeline();
+  if (virtual_pipeline == nullptr)
+    return HWC2::Error::Unsupported;
+
+  *display = ++last_display_handle_;
+  auto disp = std::make_unique<HwcDisplay>(*display, HWC2::DisplayType::Virtual,
+                                           this);
+
+  disp.get()->SetPipeline(virtual_pipeline);
+  displays_[*display] = std::move(disp);
+  return HWC2::Error::None;
 }
 
-HWC2::Error DrmHwcTwo::DestroyVirtualDisplay(hwc2_display_t /*display*/) {
-  // TODO(nobody): Implement virtual display
-  return HWC2::Error::Unsupported;
+HWC2::Error DrmHwcTwo::DestroyVirtualDisplay(hwc2_display_t display) {
+  ALOGI("Destroying virtual display %" PRIu64, display);
+
+  if (displays_.count(display) == 0) {
+    ALOGE("Trying to destroy non-existent display %" PRIu64, display);
+    return HWC2::Error::BadDisplay;
+  }
+
+  displays_.erase(display);
+  return HWC2::Error::None;
 }
 
 void DrmHwcTwo::Dump(uint32_t *outSize, char *outBuffer) {
@@ -156,8 +173,8 @@ void DrmHwcTwo::Dump(uint32_t *outSize, char *outBuffer) {
 }
 
 uint32_t DrmHwcTwo::GetMaxVirtualDisplayCount() {
-  // TODO(nobody): Implement virtual display
-  return 0;
+  ALOGI("Getting max virtual display count");
+  return 1;
 }
 
 HWC2::Error DrmHwcTwo::RegisterCallback(int32_t descriptor,
diff --git a/hwc2_device/HwcDisplay.cpp b/hwc2_device/HwcDisplay.cpp
index efd8c14..f75448f 100644
--- a/hwc2_device/HwcDisplay.cpp
+++ b/hwc2_device/HwcDisplay.cpp
@@ -67,7 +67,11 @@ std::string HwcDisplay::Dump() {
 
 HwcDisplay::HwcDisplay(hwc2_display_t handle, HWC2::DisplayType type,
                        DrmHwcTwo *hwc2)
-    : hwc2_(hwc2), handle_(handle), type_(type), client_layer_(this){};
+    : hwc2_(hwc2), handle_(handle), type_(type), client_layer_(this) {
+  if (type_ == HWC2::DisplayType::Virtual) {
+    writeback_layer_ = std::make_unique<HwcLayer>(this);
+  }
+}
 
 void HwcDisplay::SetColorMarixToIdentity() {
   color_matrix_ = std::make_shared<drm_color_ctm>();
@@ -190,7 +194,7 @@ HWC2::Error HwcDisplay::Init() {
 
 HWC2::Error HwcDisplay::ChosePreferredConfig() {
   HWC2::Error err{};
-  if (!IsInHeadlessMode()) {
+  if (!IsInHeadlessMode() && type_ != HWC2::DisplayType::Virtual) {
     err = configs_.Update(*pipeline_->connector->Get());
   } else {
     configs_.FillHeadless();
@@ -528,6 +532,13 @@ HWC2::Error HwcDisplay::CreateComposition(AtomicCommitArgs &a_args) {
    */
   current_plan_ = DrmKmsPlan::CreateDrmKmsPlan(GetPipe(),
                                                std::move(composition_layers));
+
+  if (type_ == HWC2::DisplayType::Virtual) {
+    writeback_layer_->PopulateLayerData();
+    a_args.writeback_fb = writeback_layer_->GetLayerData().fb;
+    a_args.writeback_release_fence = writeback_layer_->GetLayerData().acquire_fence;
+  }
+
   if (!current_plan_) {
     if (!a_args.test_only) {
       ALOGE("Failed to create DrmKmsPlan");
@@ -722,10 +733,10 @@ bool HwcDisplay::CtmByGpu() {
   return true;
 }
 
-HWC2::Error HwcDisplay::SetOutputBuffer(buffer_handle_t /*buffer*/,
-                                        int32_t /*release_fence*/) {
-  // TODO(nobody): Need virtual display support
-  return HWC2::Error::Unsupported;
+HWC2::Error HwcDisplay::SetOutputBuffer(buffer_handle_t buffer,
+                                        int32_t release_fence) {
+  writeback_layer_->SetLayerBuffer(buffer, release_fence);
+  return HWC2::Error::None;
 }
 
 HWC2::Error HwcDisplay::SetPowerMode(int32_t mode_in) {
@@ -773,6 +784,10 @@ HWC2::Error HwcDisplay::SetPowerMode(int32_t mode_in) {
 }
 
 HWC2::Error HwcDisplay::SetVsyncEnabled(int32_t enabled) {
+  if (type_ == HWC2::DisplayType::Virtual) {
+    return HWC2::Error::None;
+  }
+
   vsync_event_en_ = HWC2_VSYNC_ENABLE == enabled;
   if (vsync_event_en_) {
     vsync_worker_->VSyncControl(true);
diff --git a/hwc2_device/HwcDisplay.h b/hwc2_device/HwcDisplay.h
index bf95c3e..930fdea 100644
--- a/hwc2_device/HwcDisplay.h
+++ b/hwc2_device/HwcDisplay.h
@@ -182,6 +182,10 @@ class HwcDisplay {
     return flatcon_;
   }
 
+  auto &GetWritebackLayer() {
+    return writeback_layer_;
+  }
+
  private:
   HwcDisplayConfigs configs_;
 
@@ -210,6 +214,7 @@ class HwcDisplay {
 
   std::map<hwc2_layer_t, HwcLayer> layers_;
   HwcLayer client_layer_;
+  std::unique_ptr<HwcLayer> writeback_layer_;
   int32_t color_mode_{};
   static constexpr int kCtmRows = 3;
   static constexpr int kCtmCols = 3;
diff --git a/hwc2_device/HwcDisplayConfigs.cpp b/hwc2_device/HwcDisplayConfigs.cpp
index d281cdb..1b5810a 100644
--- a/hwc2_device/HwcDisplayConfigs.cpp
+++ b/hwc2_device/HwcDisplayConfigs.cpp
@@ -39,12 +39,29 @@ void HwcDisplayConfigs::FillHeadless() {
 
   last_config_id++;
   preferred_config_id = active_config_id = last_config_id;
+  // auto headless_drm_mode_info = (drmModeModeInfo){
+  //     .hdisplay = kHeadlessModeDisplayWidthPx,
+  //     .vdisplay = kHeadlessModeDisplayHeightPx,
+  //     .vrefresh = kHeadlessModeDisplayVRefresh,
+  //     .name = "HEADLESS-MODE",
+  // };
   auto headless_drm_mode_info = (drmModeModeInfo){
-      .hdisplay = kHeadlessModeDisplayWidthPx,
-      .vdisplay = kHeadlessModeDisplayHeightPx,
-      .vrefresh = kHeadlessModeDisplayVRefresh,
+      65000,
+      1024,
+      1048,
+      1184,
+      1344,
+      0,
+      768,
+      771,
+      777,
+      806,
+      0,
+      .vrefresh = 60,
+      .flags = DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC,
       .name = "HEADLESS-MODE",
   };
+
   hwc_configs[active_config_id] = (HwcDisplayConfig){
       .id = active_config_id,
       .group_id = 1,
-- 
2.39.2

